<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AR Moon + Bunny Line Draw (Final)</title>
<style>
body { margin:0; overflow:hidden; }
#ui {
  position:fixed;
  top:10px; left:10px;
  z-index:9999;
  display:flex;
  flex-direction:column;
  gap:8px;
}
#status, button {
  background:rgba(0,0,0,0.7);
  color:white;
  border:none;
  border-radius:6px;
  padding:8px 12px;
  font-size:14px;
}
.ar-button {
  background:rgba(0,0,0,0.85)!important;
  border:1px solid rgba(255,255,255,0.5)!important;
}
</style>
</head>

<body>
<div id="ui">
  <div id="status">AR ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”.</div>
  <button id="btnGuide">ğŸ“¸ ìº¡ì²˜ ë°©ë²• ì•ˆë‚´</button>
  <button id="btnEnd" style="display:none">âŒ AR ì¢…ë£Œ</button>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

let scene, camera, renderer, controller;
let moon, moonGroup;
let phase = 0;
let eclipseProgress = 0;
let moonRotate = true;

let bunnySprite = null;
let bunnyEverAppeared = false;
let bunnyTouched = false;

const raycaster = new THREE.Raycaster();
const status = document.getElementById('status');
const btnEnd = document.getElementById('btnEnd');
const btnGuide = document.getElementById('btnGuide');

/* ===== í† ë¼ ë¼ì¸ ìº”ë²„ìŠ¤ ===== */
const lineCanvas = document.createElement('canvas');
lineCanvas.width = lineCanvas.height = 1024;
const lineCtx = lineCanvas.getContext('2d');
const lineTexture = new THREE.CanvasTexture(lineCanvas);

let lineProgress = 0;
let lineUV = null;

/* ===== í† ë¼ ë¼ì¸ ê²½ë¡œ ì •ì˜ ===== */
const bunnyPath = [
  [0.5,0.25],[0.45,0.15],[0.4,0.05], // ì™¼ìª½ ê·€
  [0.5,0.25],[0.55,0.15],[0.6,0.05], // ì˜¤ë¥¸ìª½ ê·€
  [0.35,0.35],[0.65,0.35],           // ì–¼êµ´ ìƒë‹¨
  [0.7,0.55],[0.5,0.7],[0.3,0.55],   // ì–¼êµ´ í•˜ë‹¨
  [0.35,0.35]
];

init();

function init(){
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

  renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const arBtn = ARButton.createButton(renderer);
  arBtn.classList.add('ar-button');
  document.body.appendChild(arBtn);

  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.1));

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelect);
  scene.add(controller);

  renderer.xr.addEventListener('sessionstart', ()=>{
    status.innerText = "í™”ë©´ì„ íƒ­í•˜ë©´ ë³´ë¦„ë‹¬ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤ ğŸŒ•";
    btnEnd.style.display = 'block';
  });

  renderer.xr.addEventListener('sessionend', cleanup);
  renderer.setAnimationLoop(render);
}

function onSelect(){
  raycaster.setFromCamera({x:0,y:0}, camera);

  if (phase === 0){
    createMoon();
    phase = 1;
    status.innerText = "ğŸŒ• ë…¸ë€ ë³´ë¦„ë‹¬";
    return;
  }

  const hitMoon = raycaster.intersectObject(moon);
  if (hitMoon.length){
    if (phase === 1){
      phase = 2;
      eclipseProgress = 0;
      moon.material.uniforms.eclipseActive.value = true;
      status.innerText = "ğŸŒ˜ ì›”ì‹";
    } else if (phase === 2){
      phase = 3;
      moon.material.uniforms.phase.value = 2.0;
      status.innerText = "ğŸŒ‘ ë¶‰ì€ ë‹¬";
    }
    return;
  }

  if (!bunnyEverAppeared){
    spawnBunny();
    bunnyEverAppeared = true;
  }
}

function spawnBunny(){
  const tex = new THREE.TextureLoader().load('https://i.imgur.com/9WfhK7C.png');
  bunnySprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex, transparent:true}));
  bunnySprite.scale.set(0.3,0.3,1);

  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  bunnySprite.position.copy(camera.position).add(dir.multiplyScalar(1));

  scene.add(bunnySprite);
}

function startLineDraw(uv){
  lineUV = uv.clone();
  lineProgress = 0;
  lineCtx.clearRect(0,0,1024,1024);
}

function drawLineStep(){
  if (!lineUV) return;

  lineProgress += 0.015;
  const maxSeg = Math.floor(bunnyPath.length * lineProgress);

  const cx = lineUV.x * 1024;
  const cy = (1 - lineUV.y) * 1024;
  const scale = 260;

  lineCtx.strokeStyle = 'rgba(255,230,180,0.95)';
  lineCtx.lineWidth = 10;
  lineCtx.lineCap = 'round';
  lineCtx.beginPath();

  for (let i=0;i<maxSeg;i++){
    const p = bunnyPath[i];
    const x = cx + (p[0]-0.5)*scale;
    const y = cy + (p[1]-0.5)*scale;
    if (i===0) lineCtx.moveTo(x,y);
    else lineCtx.lineTo(x,y);
  }

  lineCtx.stroke();
  lineTexture.needsUpdate = true;

  if (lineProgress >= 1){
    lineUV = null;
    moonRotate = true;
  }
}

function render(){
  if (moonGroup && moonRotate) moonGroup.rotation.y += 0.003;

  if (bunnySprite && !bunnyTouched){
    raycaster.setFromCamera({x:0,y:0}, camera);
    const hit = raycaster.intersectObject(bunnySprite);
    if (hit.length){
      bunnyTouched = true;
      scene.remove(bunnySprite);

      const moonHit = raycaster.intersectObject(moon)[0];
      if (moonHit){
        moonRotate = false;
        startLineDraw(moonHit.uv);
      }
    }
  }

  if (phase === 2 && eclipseProgress < 1){
    eclipseProgress += 0.003;
    moon.material.uniforms.eclipse.value = eclipseProgress * 2;
  }

  drawLineStep();
  renderer.render(scene, camera);
}

function createMoon(){
  const loader = new THREE.TextureLoader();
  moonGroup = new THREE.Group();

  const mat = new THREE.ShaderMaterial({
    uniforms:{
      map:{value:loader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg')},
      lineMap:{value:lineTexture},
      eclipse:{value:0},
      eclipseActive:{value:false},
      phase:{value:0}
    },
    vertexShader:`
      varying vec2 vUv;
      varying vec3 vNormal;
      void main(){
        vUv=uv;
        vNormal=normalize(normalMatrix*normal);
        gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);
      }
    `,
    fragmentShader:`
      uniform sampler2D map;
      uniform sampler2D lineMap;
      uniform float eclipse;
      uniform bool eclipseActive;
      uniform float phase;
      varying vec2 vUv;
      varying vec3 vNormal;
      void main(){
        vec3 c=texture2D(map,vUv).rgb;
        c=pow(c,vec3(0.75))*vec3(1.2,1.15,0.95);
        if(eclipseActive){
          float e=smoothstep(-1.+eclipse,-0.2+eclipse,vNormal.x);
          c*=mix(0.3,1.,e);
        }
        if(phase>1.5) c=vec3(c.r*1.2,c.g*0.6,c.b*0.55);
        vec4 line=texture2D(lineMap,vUv);
        c=mix(c,vec3(1.3,1.0,0.7),line.r);
        gl_FragColor=vec4(c,1.);
      }
    `
  });

  moon = new THREE.Mesh(new THREE.SphereGeometry(0.15,64,64), mat);
  moonGroup.add(moon);

  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  moonGroup.position.copy(camera.position).add(dir.multiplyScalar(1));
  scene.add(moonGroup);
}

function cleanup(){
  phase=0;
  bunnyEverAppeared=false;
  bunnyTouched=false;
  status.innerText="AR ì¢…ë£Œë¨";
}

btnEnd.onclick = () => {
  const session = renderer.xr.getSession();
  if (session) session.end();
};

btnGuide.onclick = () => {
  alert(
    "ğŸ“¸ AR í™”ë©´ ìº¡ì²˜/ë…¹í™” ì•ˆë‚´\n\n" +
    "â€¢ ìº¡ì²˜: ì „ì› + ë³¼ë¥¨ í•˜ë‹¨\n" +
    "  (ì‚¬ìš©ë²„íŠ¼ì€ ê°œì¸ì„¤ì •ì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.)\n" +
    "â€¢ ë…¹í™”: ìƒë‹¨ ì•Œë¦¼ì°½ â†’ í™”ë©´ ë…¹í™”\n\n" +
    "ì›¹ ARì€ ë¸Œë¼ìš°ì € í•©ì„± í™”ë©´ì´ë¯€ë¡œ\n" +
    "ì›¹ì—ì„œ ì§ì ‘ ì €ì¥ì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤."
  );
};
</script>
</body>
</html>
