<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebXR AR ë³´ë¦„ë‹¬ + í† ë¼ (ìµœì¢…)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #ui {
      position: fixed;
      z-index: 9999;
      left: 10px;
      top: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    button {
      padding: 10px 14px;
      font-size: 14px;
      border-radius: 6px;
      border: none;
      background: rgba(0,0,0,0.7);
      color: white;
    }
    #status {
      padding: 8px 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      border-radius: 6px;
      font-size: 14px;
    }
    .ar-button {
      background: rgba(0,0,0,0.85) !important;
      color: #fff !important;
      border: 1px solid rgba(255,255,255,0.5) !important;
      font-weight: 600 !important;
    }
  </style>
</head>
<body>
<div id="ui">
  <div id="status">AR ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”.</div>
  <button id="btnGuide">ğŸ“¸ ìº¡ì²˜/ë…¹í™” ë°©ë²• ì•ˆë‚´</button>
  <button id="btnEnd" style="display:none">âŒ AR ì¢…ë£Œ</button>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

let camera, scene, renderer, controller;
let moonGroup, moon, glow;
let phase = 0;
let eclipseProgress = 0;
let moonRotate = true;

const status = document.getElementById('status');
const btnGuide = document.getElementById('btnGuide');
const btnEnd = document.getElementById('btnEnd');

const raycaster = new THREE.Raycaster();

let bunnySprite = null;
let bunnyTexture, bunnyMaskCanvas, bunnyMaskTexture;
let drawAnimation = null;

let ignoreTouchUntil = 0;
let moonTouchCooldown = 0;

let bunnySpawned = false;
let bunnyTouched = false;

init();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

  renderer = new THREE.WebGLRenderer({ alpha:true, antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const arBtn = ARButton.createButton(renderer);
  arBtn.classList.add('ar-button');
  document.body.appendChild(arBtn);

  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelectXR);
  scene.add(controller);

  renderer.xr.addEventListener('sessionstart', () => {
    status.innerText = "í™”ë©´ì„ íƒ­í•˜ë©´ ë³´ë¦„ë‹¬ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤ ğŸŒ•";
    btnEnd.style.display = 'block';
  });

  renderer.xr.addEventListener('sessionend', cleanupMoon);
  renderer.setAnimationLoop(render);

  window.addEventListener('pointerdown', onPointerDown);

  bunnyTexture = createFullBodyBunnyTexture('#ff8ab8', true);

  bunnyMaskCanvas = document.createElement('canvas');
  bunnyMaskCanvas.width = bunnyMaskCanvas.height = 1024;
  const ctx = bunnyMaskCanvas.getContext('2d');
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, 1024, 1024);

  bunnyMaskTexture = new THREE.CanvasTexture(bunnyMaskCanvas);
  bunnyMaskTexture.needsUpdate = true;
}

function getCameraForRaycast() {
  const xrCamera = renderer.xr.getCamera(camera);
  if (xrCamera.isArrayCamera) return xrCamera.cameras[0];
  return xrCamera;
}

function onPointerDown(event) {
  if (event.target.tagName === 'BUTTON') return;
  if (performance.now() < ignoreTouchUntil) return;

  const x = (event.clientX / window.innerWidth) * 2 - 1;
  const y = -(event.clientY / window.innerHeight) * 2 + 1;
  const cam = getCameraForRaycast();

  raycaster.setFromCamera({x, y}, cam);

  if (phase === 0) {
    createMoon();
    phase = 1;
    status.innerText = "ğŸŒ• ë…¸ë€ ë³´ë¦„ë‹¬";
    ignoreTouchUntil = performance.now() + 300;
    return;
  }

  if (moon) {
    const intersectsMoon = raycaster.intersectObject(moon);
    if (intersectsMoon.length > 0) {
      onMoonTouched();
      return;
    }
  }

  if (!bunnySpawned && !bunnyTouched) {
    bunnySpawned = true;
    bunnySprite = createBunnySprite();
    spawnBunnyAtCameraForward();
  }
}

function onSelectXR() {
  if (performance.now() < ignoreTouchUntil) return;

  const origin = new THREE.Vector3();
  const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(controller.quaternion);
  controller.getWorldPosition(origin);
  raycaster.set(origin, dir);

  if (phase === 0) {
    createMoon();
    phase = 1;
    status.innerText = "ğŸŒ• ë…¸ë€ ë³´ë¦„ë‹¬";
    ignoreTouchUntil = performance.now() + 300;
    return;
  }

  if (moon) {
    const intersectsMoon = raycaster.intersectObject(moon);
    if (intersectsMoon.length > 0) {
      onMoonTouched();
      return;
    }
  }

  if (!bunnySpawned && !bunnyTouched) {
    bunnySpawned = true;
    bunnySprite = createBunnySprite();
    spawnBunnyAtCameraForward();
  }
}

function onMoonTouched() {
  if (performance.now() < moonTouchCooldown) return;
  moonTouchCooldown = performance.now() + 500;

  if (phase === 1) {
    phase = 2;
    eclipseProgress = 0;
    moon.material.uniforms.eclipseActive.value = true;
    status.innerText = "ğŸŒ˜ ì›”ì‹ì´ ì‹œì‘ë©ë‹ˆë‹¤";
    return;
  }

  if (phase === 2) {
    moon.material.uniforms.phase.value = 2.0;
    glow.material.color.set(0xffb088);
    glow.material.opacity = 0.45;
    phase = 3;
    status.innerText = "ğŸŒ‘ ì€ì€í•œ ë¶‰ì€ ë‹¬";
  }
}

function spawnBunnyAtCameraForward() {
  if (!bunnySprite) return;
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  bunnySprite.position.copy(camera.position).add(dir.multiplyScalar(1.0));

  bunnySprite.scale.set(0.3, 0.3, 1);
  scene.add(bunnySprite);
}

function createBunnySprite() {
  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
    map: bunnyTexture,
    transparent: true,
    opacity: 1.0
  }));
  sprite.userData.isBunny = true;
  return sprite;
}

function createFullBodyBunnyTexture(color, colored = true) {
  const size = 512;
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, size, size);

  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(256, 320, 110, 140, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.beginPath();
  ctx.ellipse(256, 190, 90, 90, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.beginPath();
  ctx.ellipse(180, 90, 40, 120, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(332, 90, 40, 120, 0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(230, 190, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(282, 190, 12, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#ff5a8a';
  ctx.beginPath();
  ctx.arc(256, 220, 10, 0, Math.PI * 2);
  ctx.fill();

  if (colored) {
    ctx.fillStyle = 'rgba(255, 140, 200, 0.7)';
    ctx.beginPath();
    ctx.arc(216, 220, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(296, 220, 18, 0, Math.PI * 2);
    ctx.fill();
  }

  return new THREE.CanvasTexture(canvas);
}

function drawBunnyOnMoonMask(uv, alpha) {
  const ctx = bunnyMaskCanvas.getContext('2d');
  const size = 220;
  const x = uv.x * bunnyMaskCanvas.width - size / 2;
  const y = (1 - uv.y) * bunnyMaskCanvas.height - size / 2;

  ctx.save();
  ctx.globalCompositeOperation = 'source-over';
  ctx.globalAlpha = alpha;
  ctx.fillStyle = 'black';

  ctx.beginPath();
  ctx.ellipse(x + size/2, y + size*0.65, size*0.35, size*0.4, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size*0.28, y + size*0.2, size*0.15, size*0.3, -0.3, 0, Math.PI * 2);
  ctx.ellipse(x + size*0.72, y + size*0.2, size*0.15, size*0.3, 0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
  bunnyMaskTexture.needsUpdate = true;
}

function render() {
  if (moonGroup && moonRotate) moonGroup.rotation.y += 0.003;

  if (bunnySprite && !bunnyTouched) {
    const cam = getCameraForRaycast();
    raycaster.setFromCamera({x:0, y:0}, cam);

    if (renderer.xr.isPresenting) {
      const origin = new THREE.Vector3();
      const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(controller.quaternion);
      controller.getWorldPosition(origin);
      raycaster.set(origin, dir);
    }

    // ë‹¬ í‘œë©´ì— ë‹¿ì€ ìœ„ì¹˜ ê³„ì‚°
    const intersectsMoon = raycaster.intersectObject(moon);
    if (intersectsMoon.length > 0) {
      const hit = intersectsMoon[0];
      bunnyTouched = true;

      // í† ë¼ ìœ„ì¹˜ë¥¼ ë‹¬ í‘œë©´ì— ê³ ì •
      bunnySprite.position.copy(hit.point);

      // ë²•ì„  ë°©í–¥ì„ í–¥í•˜ê²Œ (ë‹¬ í‘œë©´ì˜ ì •ë©´ ë°©í–¥)
      const normal = hit.face.normal.clone().transformDirection(moon.matrixWorld);
      const lookPos = hit.point.clone().add(normal);
      bunnySprite.lookAt(lookPos);

      // ë‹¬ íšŒì „ ë©ˆì¶¤
      moonRotate = false;

      startDrawAnimation(hit.uv);

      scene.remove(bunnySprite);
      bunnySprite = null;
    }
  }

  if (drawAnimation) drawAnimation();

  if (moonGroup && phase === 2 && eclipseProgress < 1) {
    eclipseProgress += 0.003;
    moon.material.uniforms.eclipse.value = eclipseProgress * 2.0;
    glow.material.opacity = THREE.MathUtils.lerp(0.45, 0.12, eclipseProgress);
  }

  renderer.render(scene, camera);
}

function startDrawAnimation(uv) {
  let progress = 0;
  drawAnimation = () => {
    progress += 0.02;
    if (progress >= 1) {
      progress = 1;
      drawAnimation = null;
      // 2ë²ˆ: ê·¸ë ¤ì§„ í›„ ë‹¬ì´ ë‹¤ì‹œ íšŒì „ ì‹œì‘
      moonRotate = true;
    }
    drawBunnyOnMoonMask(uv, progress);
  };
}

function createMoon() {
  const loader = new THREE.TextureLoader();
  moonGroup = new THREE.Group();

  const material = new THREE.ShaderMaterial({
    uniforms: {
      map: { value: loader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg') },
      maskMap: { value: bunnyMaskTexture },
      eclipse: { value: 0.0 },
      eclipseActive: { value: false },
      phase: { value: 0.0 }
    },
    vertexShader: `
      varying vec2 vUv;
      varying vec3 vNormal;
      void main() {
        vUv = uv;
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D map;
      uniform sampler2D maskMap;
      uniform float eclipse;
      uniform bool eclipseActive;
      uniform float phase;
      varying vec2 vUv;
      varying vec3 vNormal;

      void main() {
        vec3 base = texture2D(map, vUv).rgb;

        float luma = dot(base, vec3(0.299, 0.587, 0.114));
        base = mix(vec3(luma), base, 1.4);
        base = pow(base, vec3(0.75));

        vec3 color = base * vec3(1.2, 1.15, 0.95);

        float light = dot(normalize(vNormal), vec3(0.15, 0.0, 1.0));
        light = clamp(light, 0.6, 1.0);
        color *= light;

        if (eclipseActive) {
          float edge = smoothstep(-1.0 + eclipse, -0.2 + eclipse, vNormal.x);
          color *= mix(0.3, 1.0, edge);
        }

        if (phase > 1.5) {
          color = base * vec3(1.2, 0.6, 0.55);
        }

        vec4 mask = texture2D(maskMap, vUv);
        if (mask.r < 0.5) {
          color = mix(color, vec3(1.2, 0.8, 0.6), 0.9);
        }

        gl_FragColor = vec4(color, 1.0);
      }
    `
  });

  moon = new THREE.Mesh(new THREE.SphereGeometry(0.15, 64, 64), material);
  moonGroup.add(moon);

  glow = new THREE.Sprite(new THREE.SpriteMaterial({
    map: loader.load('https://threejs.org/examples/textures/sprites/glow.png'),
    color: 0xffe3a0,
    transparent: true,
    opacity: 0.45
  }));
  glow.scale.set(0.6,0.6,1);
  moonGroup.add(glow);

  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  moonGroup.position.copy(camera.position).add(dir.multiplyScalar(1));
  scene.add(moonGroup);
}

function cleanupMoon() {
  if (!moonGroup) return;

  moonGroup.traverse(o => {
    if (o.geometry) o.geometry.dispose();
    if (o.material) o.material.dispose();
  });

  scene.remove(moonGroup);
  moonGroup = null;
  phase = 0;
  moonRotate = true;
  status.innerText = "AR ì¢…ë£Œë¨";
  btnEnd.style.display = 'none';

  if (bunnySprite) {
    scene.remove(bunnySprite);
    bunnySprite = null;
  }
  bunnySpawned = false;
  bunnyTouched = false;
}

btnEnd.onclick = () => {
  const session = renderer.xr.getSession();
  if (session) session.end();
};

btnGuide.onclick = () => {
  alert(
    "ğŸ“¸ AR í™”ë©´ ìº¡ì²˜/ë…¹í™” ì•ˆë‚´\n\n" +
    "â€¢ ìº¡ì²˜: ì „ì› + ë³¼ë¥¨ í•˜ë‹¨\n" +
    "  (ì‚¬ìš©ë²„íŠ¼ì€ ê°œì¸ì„¤ì •ì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.)\n" +
    "â€¢ ë…¹í™”: ìƒë‹¨ ì•Œë¦¼ì°½ â†’ í™”ë©´ ë…¹í™”\n\n" +
    "ì›¹ ARì€ ë¸Œë¼ìš°ì € í•©ì„± í™”ë©´ì´ë¯€ë¡œ\n" +
    "ì›¹ì—ì„œ ì§ì ‘ ì €ì¥ì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤."
  );
};
</script>
</body>
</html>
