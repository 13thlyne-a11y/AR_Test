<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebXR AR ë³´ë¦„ë‹¬ + í† ë¼ (ìµœì¢…)</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #ui {
      position: fixed;
      z-index: 9999;
      left: 10px;
      top: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    button {
      padding: 10px 14px;
      font-size: 14px;
      border-radius: 6px;
      border: none;
      background: rgba(0,0,0,0.7);
      color: white;
    }
    #status {
      padding: 8px 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      border-radius: 6px;
      font-size: 14px;
    }
    .ar-button {
      background: rgba(0,0,0,0.85) !important;
      color: #fff !important;
      border: 1px solid rgba(255,255,255,0.5) !important;
      font-weight: 600 !important;
    }
  </style>
</head>
<body>
<div id="ui">
  <div id="status">AR ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”.</div>
  <button id="btnGuide">ğŸ“¸ ìº¡ì²˜/ë…¹í™” ë°©ë²• ì•ˆë‚´</button>
  <button id="btnEnd" style="display:none">âŒ AR ì¢…ë£Œ</button>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

let camera, scene, renderer, controller;
let moonGroup, moon, glow;
let phase = 0;
let eclipseProgress = 0;

const status = document.getElementById('status');
const btnGuide = document.getElementById('btnGuide');
const btnEnd = document.getElementById('btnEnd');

const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

const bunnySprites = [];
let bunnyTexture, bunnyMaskCanvas, bunnyMaskTexture;

let lastPointer = { x: 0, y: 0 };  // ë§ˆì§€ë§‰ í„°ì¹˜ ì¢Œí‘œ ì €ì¥

init();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

  renderer = new THREE.WebGLRenderer({ alpha:true, antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const arBtn = ARButton.createButton(renderer);
  arBtn.classList.add('ar-button');
  document.body.appendChild(arBtn);

  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));

  controller = renderer.xr.getController(0);
  controller.addEventListener('select', onSelectXR);
  scene.add(controller);

  renderer.xr.addEventListener('sessionstart', () => {
    status.innerText = "í™”ë©´ì„ íƒ­í•˜ë©´ ë³´ë¦„ë‹¬ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤ ğŸŒ•";
    btnEnd.style.display = 'block';
  });

  renderer.xr.addEventListener('sessionend', cleanupMoon);
  renderer.setAnimationLoop(render);

  window.addEventListener('pointerdown', onPointerDown);

  bunnyTexture = createBunnyTexture('#ff8ab8', true);

  bunnyMaskCanvas = document.createElement('canvas');
  bunnyMaskCanvas.width = bunnyMaskCanvas.height = 1024;
  bunnyMaskTexture = new THREE.CanvasTexture(bunnyMaskCanvas);
  bunnyMaskTexture.needsUpdate = true;
}

function onPointerDown(event) {
  // ë§ˆì§€ë§‰ í„°ì¹˜ ì¢Œí‘œ ì €ì¥ (UV ì •í™•ë„ í–¥ìƒ)
  lastPointer.x = (event.clientX / window.innerWidth) * 2 - 1;
  lastPointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

  if (renderer.xr.isPresenting) return;

  // ì²˜ìŒ í„°ì¹˜ë¡œ ë‹¬ ìƒì„±
  if (phase === 0) {
    createMoon();
    phase = 1;
    status.innerText = "ğŸŒ• ë…¸ë€ ë³´ë¦„ë‹¬";
    return;
  }

  // ë‹¬ í„°ì¹˜ ê°ì§€
  raycaster.setFromCamera(lastPointer, camera);
  if (moon) {
    const intersectsMoon = raycaster.intersectObject(moon);
    if (intersectsMoon.length > 0) {
      onMoonTouched();
      return;
    }
  }

  // ë‹¬ ì™¸ í„°ì¹˜ â†’ í† ë¼ ìƒì„±
  spawnBunnyAtCameraForward();
}

function onSelectXR() {
  // XRì—ì„œëŠ” controller ë ˆì´ ì‚¬ìš©
  if (phase === 0) {
    createMoon();
    phase = 1;
    status.innerText = "ğŸŒ• ë…¸ë€ ë³´ë¦„ë‹¬";
    return;
  }

  raycaster.setFromCamera({ x: 0, y: 0 }, camera);

  if (moon) {
    const intersectsMoon = raycaster.intersectObject(moon);
    if (intersectsMoon.length > 0) {
      onMoonTouched();
      return;
    }
  }

  // ë‹¬ ì™¸ í„°ì¹˜ â†’ í† ë¼ ìƒì„±
  spawnBunnyAtCameraForward();
}

function onMoonTouched() {
  if (phase === 1) {
    phase = 2;
    eclipseProgress = 0;
    moon.material.uniforms.eclipseActive.value = true;
    status.innerText = "ğŸŒ˜ ì›”ì‹ì´ ì‹œì‘ë©ë‹ˆë‹¤";
    return;
  }

  if (phase === 2) {
    moon.material.uniforms.phase.value = 2.0;
    glow.material.color.set(0xffb088);
    glow.material.opacity = 0.45;
    phase = 3;
    status.innerText = "ğŸŒ‘ ì€ì€í•œ ë¶‰ì€ ë‹¬";
  }
}

function spawnBunnyAtCameraForward() {
  const bunny = createBunnySprite();
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  bunny.position.copy(camera.position).add(dir.multiplyScalar(1.0));
  scene.add(bunny);
  bunnySprites.push(bunny);
}

function createBunnySprite() {
  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
    map: bunnyTexture,
    transparent: true,
    opacity: 1.0
  }));
  sprite.scale.set(0.3, 0.3, 1);
  sprite.userData.isBunny = true;
  return sprite;
}

function createBunnyTexture(color, colored = true) {
  const size = 256;
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, size, size);

  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.ellipse(128, 150, 60, 70, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.beginPath();
  ctx.ellipse(90, 70, 25, 60, -0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(166, 70, 25, 60, 0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(115, 150, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(141, 150, 6, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = '#ff5a8a';
  ctx.beginPath();
  ctx.arc(128, 170, 8, 0, Math.PI * 2);
  ctx.fill();

  if (colored) {
    ctx.fillStyle = 'rgba(255, 140, 200, 0.7)';
    ctx.beginPath();
    ctx.arc(110, 170, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(146, 170, 10, 0, Math.PI * 2);
    ctx.fill();
  }

  return new THREE.CanvasTexture(canvas);
}

function drawBunnyOnMoonMask(uv) {
  const ctx = bunnyMaskCanvas.getContext('2d');
  const size = 180;
  const x = uv.x * bunnyMaskCanvas.width - size / 2;
  const y = (1 - uv.y) * bunnyMaskCanvas.height - size / 2;

  ctx.save();
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = 'black';

  ctx.beginPath();
  ctx.ellipse(x + size/2, y + size*0.65, size*0.35, size*0.4, 0, 0, Math.PI * 2);
  ctx.ellipse(x + size*0.28, y + size*0.2, size*0.15, size*0.3, -0.3, 0, Math.PI * 2);
  ctx.ellipse(x + size*0.72, y + size*0.2, size*0.15, size*0.3, 0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
  bunnyMaskTexture.needsUpdate = true;
}

function render() {
  if (moonGroup) moonGroup.rotation.y += 0.003;

  // í† ë¼ í„°ì¹˜ ê°ì§€
  if (bunnySprites.length > 0) {
    // í™”ë©´ ì¤‘ì•™ì´ ì•„ë‹Œ, ë§ˆì§€ë§‰ í„°ì¹˜ ì¢Œí‘œë¡œ ì •í™•íˆ ê³„ì‚°
    raycaster.setFromCamera(lastPointer, camera);

    for (let i = bunnySprites.length - 1; i >= 0; i--) {
      const bunny = bunnySprites[i];
      const intersects = raycaster.intersectObject(bunny);

      if (intersects.length > 0) {
        // ì •í™•í•œ UV ê³„ì‚°: "í† ë¼ í„°ì¹˜ ì‹œì ì˜ í™”ë©´ ì¢Œí‘œ"ë¡œ ë‹¬ì— Raycast
        if (moon) {
          const moonHit = raycaster.intersectObject(moon);
          if (moonHit.length > 0) {
            drawBunnyOnMoonMask(moonHit[0].uv);
          }
        }

        scene.remove(bunny);
        bunnySprites.splice(i, 1);
      }
    }
  }

  // ì›”ì‹ ì§„í–‰
  if (moonGroup && phase === 2 && eclipseProgress < 1) {
    eclipseProgress += 0.003;
    moon.material.uniforms.eclipse.value = eclipseProgress * 2.0;
    glow.material.opacity = THREE.MathUtils.lerp(0.45, 0.12, eclipseProgress);
  }

  renderer.render(scene, camera);
}

function createMoon() {
  const loader = new THREE.TextureLoader();
  moonGroup = new THREE.Group();

  const material = new THREE.ShaderMaterial({
    uniforms: {
      map: { value: loader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg') },
      maskMap: { value: bunnyMaskTexture },
      eclipse: { value: 0.0 },
      eclipseActive: { value: false },
      phase: { value: 0.0 }
    },
    vertexShader: `
      varying vec2 vUv;
      varying vec3 vNormal;
      void main() {
        vUv = uv;
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D map;
      uniform sampler2D maskMap;
      uniform float eclipse;
      uniform bool eclipseActive;
      uniform float phase;
      varying vec2 vUv;
      varying vec3 vNormal;

      void main() {
        vec3 base = texture2D(map, vUv).rgb;

        float luma = dot(base, vec3(0.299, 0.587, 0.114));
        base = mix(vec3(luma), base, 1.4);
        base = pow(base, vec3(0.75));

        vec3 color = base * vec3(1.2, 1.15, 0.95);

        float light = dot(normalize(vNormal), vec3(0.15, 0.0, 1.0));
        light = clamp(light, 0.6, 1.0);
        color *= light;

        if (eclipseActive) {
          float edge = smoothstep(-1.0 + eclipse, -0.2 + eclipse, vNormal.x);
          color *= mix(0.3, 1.0, edge);
        }

        if (phase > 1.5) {
          color = base * vec3(1.2, 0.6, 0.55);
        }

        vec4 mask = texture2D(maskMap, vUv);
        if (mask.r < 0.1) {
          color = mix(color, vec3(1.2, 0.8, 0.6), 0.9);
        }

        gl_FragColor = vec4(color, 1.0);
      }
    `
  });

  moon = new THREE.Mesh(new THREE.SphereGeometry(0.15, 64, 64), material);
  moonGroup.add(moon);

  glow = new THREE.Sprite(new THREE.SpriteMaterial({
    map: loader.load('https://threejs.org/examples/textures/sprites/glow.png'),
    color: 0xffe3a0,
    transparent: true,
    opacity: 0.45
  }));
  glow.scale.set(0.6,0.6,1);
  moonGroup.add(glow);

  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);
  moonGroup.position.copy(camera.position).add(dir.multiplyScalar(1));
  scene.add(moonGroup);
}

function cleanupMoon() {
  if (!moonGroup) return;

  moonGroup.traverse(o => {
    if (o.geometry) o.geometry.dispose();
    if (o.material) o.material.dispose();
  });

  scene.remove(moonGroup);
  moonGroup = null;
  phase = 0;
  status.innerText = "AR ì¢…ë£Œë¨";
  btnEnd.style.display = 'none';
}

btnEnd.onclick = () => {
  const session = renderer.xr.getSession();
  if (session) session.end();
};

btnGuide.onclick = () => {
  alert(
    "ğŸ“¸ AR í™”ë©´ ìº¡ì²˜/ë…¹í™” ì•ˆë‚´\n\n" +
    "â€¢ ìº¡ì²˜: ì „ì› + ë³¼ë¥¨ í•˜ë‹¨\n" +
    "  (ì‚¬ìš©ë²„íŠ¼ì€ ê°œì¸ì„¤ì •ì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.)\n" +
    "â€¢ ë…¹í™”: ìƒë‹¨ ì•Œë¦¼ì°½ â†’ í™”ë©´ ë…¹í™”\n\n" +
    "ì›¹ ARì€ ë¸Œë¼ìš°ì € í•©ì„± í™”ë©´ì´ë¯€ë¡œ\n" +
    "ì›¹ì—ì„œ ì§ì ‘ ì €ì¥ì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤."
  );
};
</script>
</body>
</html>
